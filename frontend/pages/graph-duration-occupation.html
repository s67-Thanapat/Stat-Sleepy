<!doctype html>
<html lang="th">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ชั่วโมงนอน × อาชีพ (Box plot)</title>
  <link rel="stylesheet" href="../css/styles.css" />

  <!-- Chart.js v4 -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
  <!-- ✅ ปลั๊กอิน Box/Violin สำหรับ Chart.js v4 -->
  <script src="https://cdn.jsdelivr.net/npm/@sgratzl/chartjs-chart-boxplot@4/build/index.umd.min.js"></script>
</head>

<body>
  <header class="container">
    <h1>ชั่วโมงนอน × อาชีพ (Box plot)</h1>
    <nav><a href="../index.html">← กลับหน้าแรก</a></nav>
  </header>

  <main class="container">
    <section class="chart" style="height:360px;">
      <canvas id="boxPlot"></canvas>
      <p class="muted" style="margin-top:8px;">
        กล่อง: Q1–Q3 • เส้นกลาง: มัธยฐาน • ▲: ค่าเฉลี่ย • แกน Y = ชั่วโมง/คืน
      </p>
    </section>
  </main>

  <!-- ใช้ไฟล์เดิมในโปรเจกต์ -->
  <script src="../js/config.js"></script>
  <script src="../js/api.js"></script>

  <script>
    // ---------- helpers ----------
    function groupBy(rows, keyFn, valFn) {
      const m = new Map();
      for (const r of rows) {
        const k = keyFn(r);
        const v = valFn(r);
        if (!k || isNaN(v)) continue;
        if (!m.has(k)) m.set(k, []);
        m.get(k).push(v);
      }
      return m;
    }
    const clampHours = (arr, min=2, max=14) =>
      arr.filter(x => typeof x === 'number' && isFinite(x) && x >= min && x <= max);

    const mean = a => a.length ? a.reduce((s,x)=>s+x,0)/a.length : 0;
    const median = a => {
      if (!a.length) return 0;
      const s = [...a].sort((x,y)=>x-y), n=s.length, m=Math.floor(n/2);
      return n%2 ? s[m] : (s[m-1]+s[m])/2;
    };

    function renderBoxPlot(groupMap) {
      // เรียงกลุ่มตามค่ามัธยฐาน (มาก→น้อย) เพื่ออ่านง่าย
      const entries = [...groupMap.entries()]
        .map(([label, arr]) => ({ label, values: arr, med: median(arr) }))
        .sort((a,b)=> b.med - a.med);

      const labels = entries.map(e => e.label);
      const series = entries.map(e => e.values);
      const means  = entries.map(e => ({ x: e.label, y: mean(e.values) }));

      const ctx = document.getElementById('boxPlot');
      if (ctx._chart) ctx._chart.destroy();

      ctx._chart = new Chart(ctx, {
        type: 'boxplot',
        data: {
          labels,
          datasets: [
            {
              label: 'ชั่วโมงต่อคืน',
              data: series,          // array ของ array
              outlierRadius: 3,
              itemRadius: 0
            },
            {
              type: 'scatter',      // ▲ แสดงค่าเฉลี่ยทับบนกล่อง
              label: 'ค่าเฉลี่ย',
              data: means,
              parsing: false,
              pointStyle: 'triangle',
              radius: 5,
              borderWidth: 0
            }
          ]
        },
        options: {
          responsive: true,
          plugins: {
            legend: { display: false },
            title: { display: true, text: 'Boxplot: Sleep Duration by Occupation' },
            tooltip: { intersect: false }
          },
          scales: {
            x: { ticks: { maxRotation: 60, minRotation: 30 } },
            y: {
              title: { display: true, text: 'Hours' },
              suggestedMin: 4,
              suggestedMax: 10
            }
          }
        }
      });
    }

    // ---------- main ----------
    (async function () {
      const rows = await (fetchAllSessions?.(1000) ?? []); // ดึงจาก Supabase
      if (!rows.length) return;

      // ใช้ชื่อคอลัมน์ตามตาราง Supabase (มีช่องว่างให้ใช้ bracket notation)
      const grouped = groupBy(
        rows,
        r => String(r['Occupation'] ?? '').trim(),
        r => Number(r['Sleep Duration'])
      );

      // กรองค่าเพี้ยน และลบกลุ่มที่ว่างเปล่า
      for (const [k, arr] of grouped) {
        const cleaned = clampHours(arr);
        if (cleaned.length) grouped.set(k, cleaned);
        else grouped.delete(k);
      }

      renderBoxPlot(grouped);
    })();
  </script>
</body>
</html>
