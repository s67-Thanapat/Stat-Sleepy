<script src="../js/config.js"></script>
<script src="../js/api.js"></script>

<script>
  // ---- helpers: normalize key & find columns แบบยืดหยุ่น ----
  const norm = s => String(s).toLowerCase().replace(/[\s_]/g, '');
  function findKey(row, aliases) {
    const map = new Map(Object.keys(row).map(k => [norm(k), k]));
    for (const a of aliases) {
      const k = map.get(norm(a));
      if (k) return k;           // คืนชื่อคีย์จริงที่อยู่ในอ็อบเจ็กต์
    }
    return null;
  }
  function groupBy(rows, keyFn, valFn) {
    const m = new Map();
    for (const r of rows) {
      const k = keyFn(r);
      const v = valFn(r);
      if (!k || isNaN(v)) continue;
      if (!m.has(k)) m.set(k, []);
      m.get(k).push(v);
    }
    return m;
  }
  const clampHours = (arr, min=2, max=14) =>
    arr.filter(x => typeof x === 'number' && isFinite(x) && x>=min && x<=max);

  const mean = a => a.length ? a.reduce((s,x)=>s+x,0)/a.length : 0;
  const median = a => {
    if (!a.length) return 0;
    const s = [...a].sort((x,y)=>x-y), n=s.length, m=Math.floor(n/2);
    return n%2 ? s[m] : (s[m-1]+s[m])/2;
  };

  function renderBoxPlot(groupMap) {
    const entries = [...groupMap.entries()]
      .map(([label, values]) => ({ label, values, med: median(values) }))
      .sort((a,b)=> b.med - a.med);

    const labels = entries.map(e => e.label);
    const series = entries.map(e => e.values);
    const means  = entries.map(e => ({ x: e.label, y: mean(e.values) }));

    const ctx = document.getElementById('boxPlot');
    if (ctx._chart) ctx._chart.destroy();

    ctx._chart = new Chart(ctx, {
      type: 'boxplot',
      data: {
        labels,
        datasets: [
          { label: 'ชั่วโมงต่อคืน', data: series, outlierRadius: 3, itemRadius: 0 },
          { type: 'scatter', label: 'ค่าเฉลี่ย', data: means, parsing: false,
            pointStyle: 'triangle', radius: 5, borderWidth: 0 }
        ]
      },
      options: {
        responsive: true,
        plugins: {
          legend: { display: false },
          title: { display: true, text: 'Boxplot: Sleep Duration by Occupation' },
          tooltip: { intersect: false }
        },
        scales: {
          x: { ticks: { maxRotation: 60, minRotation: 30 } },
          y: { title: { display: true, text: 'Hours' }, suggestedMin: 4, suggestedMax: 10 }
        }
      }
    });
  }

  // ---- main ----
  (async function () {
    let rows = await (fetchAllSessions?.(1000));
    // รองรับกรณี API คืน { data: [...] }
    if (rows && !Array.isArray(rows) && Array.isArray(rows.data)) rows = rows.data;
    rows = Array.isArray(rows) ? rows : [];

    console.log('[boxplot] rows length =', rows.length);
    if (!rows.length) { console.warn('ไม่พบข้อมูลจาก Supabase'); return; }

    // หาคีย์จริงจาก sample โดยยอมรับ alias หลายแบบ (มีช่องว่าง/underscore ก็ได้)
    const sample = rows[0];
    const occKey = findKey(sample, ['Occupation','job','role','profession','อาชีพ']);
    const durKey = findKey(sample, ['Sleep Duration','sleep_duration','sleepHours','hours','duration','ชั่วโมงนอน']);

    console.log('[boxplot] sample row =', sample);
    console.log('[boxplot] detected keys ->', { occKey, durKey });

    if (!occKey || !durKey) {
      alert('หา field ไม่เจอ: ต้องมีคอลัมน์อาชีพและชั่วโมงนอน\nดู console เพื่อดูคีย์ที่มีจริง');
      return;
    }

    const grouped = groupBy(
      rows,
      r => String(r[occKey] ?? '').trim(),
      r => Number(r[durKey])
    );

    // กรองค่าเพี้ยน & ลบกลุ่มว่าง
    for (const [k, arr] of grouped) {
      const cleaned = clampHours(arr);
      if (cleaned.length) grouped.set(k, cleaned);
      else grouped.delete(k);
    }

    console.log('[boxplot] group count =', grouped.size);
    renderBoxPlot(grouped);
  })();
</script>
